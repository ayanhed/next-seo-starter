# Database and Prisma Patterns

## Prisma Schema Conventions

### Model Naming and Structure

- **Use PascalCase for model names** (`User`, `Session`, `Account`)
- **Use camelCase for field names** (`emailVerified`, `createdAt`, `updatedAt`)
- **Include timestamps** on all models (`createdAt`, `updatedAt`)
- **Add `@@map()` directives** for table names

```prisma
model User {
  id            String    @id
  name          String
  email         String
  emailVerified Boolean
  image         String?
  createdAt     DateTime
  updatedAt     DateTime
  sessions      Session[]
  accounts      Account[]

  @@unique([email])
  @@map("user")
}
```

### Field Types and Constraints

- **Use appropriate field types** for data (String, Int, Boolean, DateTime)
- **Add proper constraints** (unique, required, optional)
- **Use enums for fixed values** instead of strings
- **Include proper indexes** for performance

```prisma
enum UserRole {
  USER
  ADMIN
  MODERATOR
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  role      UserRole @default(USER)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@map("user")
}
```

### Relationships

- **Define clear relationships** between models
- **Use proper relation fields** with foreign keys
- **Include cascade behavior** where appropriate
- **Add relation names** for clarity

```prisma
model User {
  id       String    @id
  sessions Session[]
  accounts Account[]
}

model Session {
  id     String @id
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}
```

## Prisma Client Usage

### Singleton Pattern

- **Use singleton pattern** for Prisma client in [`src/lib/prisma.ts`](mdc:src/lib/prisma.ts)
- **Import from `@/lib/prisma`** instead of direct `@prisma/client` imports
- **Handle development vs production** client instances

```ts
import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;
```

### Database Operations

#### Query Patterns

- **Use proper error handling** with try-catch blocks
- **Include proper type safety** with Prisma types
- **Optimize queries** with select and include

```ts
// ✅ Good query pattern
export async function getUserWithSessions(userId: string) {
  try {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        sessions: {
          select: {
            id: true,
            createdAt: true,
            expiresAt: true,
          },
        },
      },
    });

    return user;
  } catch (error) {
    console.error("Failed to fetch user:", error);
    throw new Error("User not found");
  }
}

// ❌ Avoid direct client imports
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();
```

#### Transaction Usage

- **Use transactions** for related operations
- **Handle rollback scenarios** properly
- **Keep transactions short** and focused

```ts
export async function createUserWithSession(userData: CreateUserData) {
  return await prisma.$transaction(async (tx) => {
    const user = await tx.user.create({
      data: userData,
    });

    const session = await tx.session.create({
      data: {
        userId: user.id,
        token: generateToken(),
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours
      },
    });

    return { user, session };
  });
}
```

## Database Migrations

### Migration Best Practices

- **Use descriptive migration names** that explain the change
- **Test migrations** on development data before production
- **Include rollback strategies** for complex migrations
- **Document breaking changes** in migration comments

```sql
-- Migration: add_user_role_enum
-- Description: Add user role enum and role field to user table
-- Breaking: No

CREATE TYPE "UserRole" AS ENUM ('USER', 'ADMIN', 'MODERATOR');

ALTER TABLE "user" ADD COLUMN "role" "UserRole" NOT NULL DEFAULT 'USER';
```

### Migration Commands

- **Generate migrations**: `npx prisma migrate dev --name migration_name`
- **Apply migrations**: `npx prisma migrate deploy`
- **Reset database**: `npx prisma migrate reset`
- **View migration status**: `npx prisma migrate status`

## Data Validation

### Input Validation

- **Validate data before database operations**
- **Use Zod or similar** for runtime type validation
- **Handle validation errors** gracefully

```ts
import { z } from "zod";

const CreateUserSchema = z.object({
  email: z.string().email(),
  name: z.string().min(1).max(100),
  role: z.enum(["USER", "ADMIN"]).optional(),
});

export async function createUser(data: unknown) {
  const validatedData = CreateUserSchema.parse(data);

  return await prisma.user.create({
    data: validatedData,
  });
}
```

### Error Handling

- **Handle Prisma-specific errors** (unique constraints, foreign keys)
- **Provide meaningful error messages** to users
- **Log errors** for debugging

```ts
export async function createUser(data: CreateUserData) {
  try {
    return await prisma.user.create({ data });
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === "P2002") {
        throw new Error("User with this email already exists");
      }
    }
    throw error;
  }
}
```

## Performance Optimization

### Query Optimization

- **Use select** to fetch only needed fields
- **Use include** for related data when needed
- **Add database indexes** for frequently queried fields
- **Use pagination** for large result sets

```ts
// ✅ Optimized query
const users = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    email: true,
    createdAt: true,
  },
  where: {
    isActive: true,
  },
  orderBy: {
    createdAt: "desc",
  },
  take: 20,
  skip: 0,
});

// ❌ Fetching unnecessary data
const users = await prisma.user.findMany({
  include: {
    sessions: true,
    accounts: true,
  },
});
```

### Connection Management

- **Use connection pooling** in production
- **Handle connection limits** appropriately
- **Monitor query performance** with logging

## Security Considerations

### SQL Injection Prevention

- **Use Prisma's parameterized queries** (automatic)
- **Never concatenate user input** into raw SQL
- **Validate all inputs** before database operations

### Data Access Control

- **Implement row-level security** where needed
- **Use proper authentication** for database access
- **Audit sensitive operations** with logging

## Testing Database Operations

### Test Setup

- **Use test database** for integration tests
- **Reset database state** between tests
- **Mock database calls** for unit tests

```ts
// Test setup
beforeEach(async () => {
  await prisma.user.deleteMany();
  await prisma.session.deleteMany();
});

afterAll(async () => {
  await prisma.$disconnect();
});
```

### Test Data

- **Use factories** for creating test data
- **Clean up test data** after tests
- **Use realistic test scenarios**
  description:
  globs:
  alwaysApply: true

---
