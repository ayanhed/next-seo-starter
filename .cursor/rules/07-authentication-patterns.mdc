# Authentication Patterns

## Better Auth Integration

### Configuration

- **Use Better Auth** for authentication management
- **Configure auth handlers** in [`src/lib/auth.ts`](mdc:src/lib/auth.ts)
- **Set up client helpers** in [`src/lib/auth-client.ts`](mdc:src/lib/auth-client.ts)
- **Handle API routes** in [`src/app/api/auth/[...all]/route.ts`](mdc:src/app/api/auth/[...all]/route.ts)

### Auth Setup Pattern

```ts
// src/lib/auth.ts
import { NextAuth } from "better-auth";
import { prisma } from "./prisma";

export const auth = NextAuth({
  adapter: PrismaAdapter(prisma),
  providers: [
    // Configure providers
  ],
  callbacks: {
    session: ({ session, user }) => ({
      ...session,
      user: {
        ...session.user,
        id: user.id,
      },
    }),
  },
});
```

## Session Management

### Session Handling

- **Use server-side session validation** for protected routes
- **Handle anonymous users** with `isAnonymous` field
- **Implement proper session expiry** and cleanup

```tsx
// Server component session check
import { auth } from "@/lib/auth";

export default async function ProtectedPage() {
  const session = await auth();

  if (!session?.user) {
    redirect("/login");
  }

  return (
    <div>
      <h1>Welcome, {session.user.name}</h1>
      {/* Protected content */}
    </div>
  );
}
```

### Client-Side Session

- **Use client helpers** for client-side session management
- **Handle loading states** during authentication
- **Provide proper error handling** for auth failures

```tsx
// Client component session usage
"use client";

import { useSession } from "@/lib/auth-client";

export default function UserProfile() {
  const { data: session, status } = useSession();

  if (status === "loading") {
    return <div>Loading...</div>;
  }

  if (status === "unauthenticated") {
    return <div>Please log in</div>;
  }

  return (
    <div>
      <h2>Profile: {session?.user?.name}</h2>
      {/* User content */}
    </div>
  );
}
```

## Route Protection

### Middleware Protection

- **Use middleware** for route-level protection
- **Handle authentication redirects** gracefully
- **Support public routes** alongside protected ones

```ts
// middleware.ts
import { auth } from "@/lib/auth";

export default auth((req) => {
  const isLoggedIn = !!req.auth;
  const { pathname } = req.nextUrl;

  // Public routes
  if (pathname === "/" || pathname.startsWith("/api/auth")) {
    return;
  }

  // Protected routes
  if (!isLoggedIn && pathname.startsWith("/dashboard")) {
    return Response.redirect(new URL("/login", req.url));
  }

  // Redirect authenticated users away from auth pages
  if (isLoggedIn && pathname.startsWith("/login")) {
    return Response.redirect(new URL("/dashboard", req.url));
  }
});

export const config = {
  matcher: ["/((?!.+\\.[\\w]+$|_next).*)", "/", "/(api|trpc)(.*)"],
};
```

### Component-Level Protection

- **Use higher-order components** for component protection
- **Handle loading and error states** appropriately
- **Provide fallback UI** for unauthenticated users

```tsx
// Protected component wrapper
interface ProtectedComponentProps {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

export function ProtectedComponent({
  children,
  fallback,
}: ProtectedComponentProps) {
  const { data: session, status } = useSession();

  if (status === "loading") {
    return <div>Loading...</div>;
  }

  if (!session?.user) {
    return fallback || <div>Please log in to access this content</div>;
  }

  return <>{children}</>;
}
```

## Anonymous User Support

### Anonymous User Handling

- **Support anonymous usage** where appropriate
- **Track anonymous sessions** for analytics
- **Provide upgrade paths** to authenticated accounts

```tsx
// Anonymous user component
export default function AnonymousUser() {
  const { data: session } = useSession();

  if (session?.user?.isAnonymous) {
    return (
      <div className="bg-[var(--color-surface)] p-4 rounded-lg">
        <h3>Anonymous User</h3>
        <p>Some features are limited for anonymous users.</p>
        <Button onClick={() => signIn()}>Sign in for full access</Button>
      </div>
    );
  }

  return <div>Full user experience</div>;
}
```

## Security Best Practices

### Password Security

- **Use secure password hashing** (handled by Better Auth)
- **Implement password policies** (length, complexity)
- **Provide password reset functionality**

### Session Security

- **Use secure session tokens** with proper expiry
- **Implement session invalidation** on logout
- **Handle session hijacking** with token rotation

```ts
// Secure session configuration
export const auth = NextAuth({
  session: {
    strategy: "jwt",
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  jwt: {
    maxAge: 30 * 24 * 60 * 60, // 30 days
  },
  callbacks: {
    jwt: ({ token, user }) => {
      if (user) {
        token.id = user.id;
      }
      return token;
    },
  },
});
```

### CSRF Protection

- **Use CSRF tokens** for sensitive operations
- **Validate request origins** for API calls
- **Implement proper CORS** configuration

## Error Handling

### Authentication Errors

- **Handle authentication failures** gracefully
- **Provide meaningful error messages** to users
- **Log authentication errors** for security monitoring

```tsx
// Error handling in auth components
export default function LoginForm() {
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (data: LoginData) => {
    try {
      const result = await signIn("credentials", {
        email: data.email,
        password: data.password,
        redirect: false,
      });

      if (result?.error) {
        setError("Invalid email or password");
      } else {
        router.push("/dashboard");
      }
    } catch (error) {
      setError("An unexpected error occurred");
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      {error && <Alert variant="destructive">{error}</Alert>}
      {/* Form fields */}
    </form>
  );
}
```

## User Experience

### Loading States

- **Show loading indicators** during authentication
- **Handle authentication delays** gracefully
- **Provide feedback** for user actions

### Seamless Authentication

- **Implement remember me** functionality
- **Use persistent sessions** where appropriate
- **Handle authentication state** across page refreshes

## Testing Authentication

### Test Setup

- **Mock authentication** for unit tests
- **Use test users** for integration tests
- **Test authentication flows** end-to-end

```tsx
// Test authentication setup
const mockSession = {
  user: {
    id: "test-user-id",
    name: "Test User",
    email: "test@example.com",
  },
  expires: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
};

jest.mock("@/lib/auth-client", () => ({
  useSession: () => ({
    data: mockSession,
    status: "authenticated",
  }),
}));
```

### Security Testing

- **Test authentication bypass** attempts
- **Verify session management** security
- **Test error handling** for invalid credentials
  description:
  globs:
  alwaysApply: true

---
