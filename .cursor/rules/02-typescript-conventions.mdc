# TypeScript and Next.js Conventions

## TypeScript Patterns

### Component Definitions

- **Avoid `React.FC`** - Use explicit function declarations with typed props
- **Define `Props` interface** for component parameters
- **Use explicit return types** for exported functions and hooks

```tsx
interface ButtonProps {
  children: React.ReactNode;
  variant?: "primary" | "secondary";
  onClick?: () => void;
}

export default function Button({
  children,
  variant = "primary",
  onClick,
}: ButtonProps) {
  return (
    <button className={`btn btn-${variant}`} onClick={onClick}>
      {children}
    </button>
  );
}
```

### Type Safety

- **Avoid `any` and unsafe casts** - Model complex types explicitly
- **Use type-only imports** when importing types: `import type { Metadata } from "next"`
- **Add explicit return types** for exported functions and hooks

### Import Patterns

- **Use path alias `@/`** instead of relative `../../` imports
- **Import order**: external → alias (`@/…`) → relative
- **Prefer named exports** for utilities; UI components use default exports for barrel files

```ts
// ✅ Good
import { useState } from "react";
import { Button, Card } from "@/components/ui";
import { appConfig } from "@/config/app";
import { cn } from "@/lib/utils";

// ❌ Avoid
import { Button } from "../../../components/ui/Button";
```

## Next.js App Router Patterns

### Server vs Client Components

- **Server Components by default** in `app/` directory
- **Add `"use client"`** only when component needs:
  - State management (`useState`, `useReducer`)
  - Effects (`useEffect`, `useLayoutEffect`)
  - Browser APIs (`window`, `document`, `localStorage`)
  - Event handlers (`onClick`, `onSubmit`)

### File Organization

- **Keep helpers in `src/lib/`** and configuration in `src/config/`
- **Co-locate small component-specific helpers** next to components
- **Move to `src/lib/`** when helpers are reused across components

### Metadata and SEO

- **Derive metadata from `appConfig`** where possible for single source of truth
- **Use `metadataBase: new URL(appConfig.app.baseUrl)`** on top-level layout
- **Set `alternates.canonical`** for canonical URLs

```tsx
export const metadata: Metadata = {
  metadataBase: new URL(appConfig.app.baseUrl),
  alternates: { canonical: appConfig.app.baseUrl },
  title: `${appConfig.app.name} — ${pageTitle}`,
  description: appConfig.app.description,
};
```

## Database and Prisma

### Prisma Client Usage

- **Use singleton pattern** for Prisma client in [`src/lib/prisma.ts`](mdc:src/lib/prisma.ts)
- **Import from `@/lib/prisma`** instead of direct `@prisma/client` imports
- **Handle database errors** gracefully with try-catch blocks

### Schema Conventions

- **Use PascalCase** for model names (`User`, `Session`, `Account`)
- **Use camelCase** for field names (`emailVerified`, `createdAt`)
- **Add `@@map()`** directives for table names
- **Include timestamps** (`createdAt`, `updatedAt`) on models

## Authentication Patterns

### Better Auth Integration

- **Use auth helpers** from [`src/lib/auth.ts`](mdc:src/lib/auth.ts) and [`src/lib/auth-client.ts`](mdc:src/lib/auth-client.ts)
- **Handle anonymous users** with `isAnonymous` field
- **Protect routes** with middleware when needed

## Error Handling

### API Routes

- **Use proper HTTP status codes** (200, 201, 400, 401, 404, 500)
- **Return consistent error responses** with error messages
- **Validate input data** before processing

```ts
export async function POST(request: Request) {
  try {
    const body = await request.json();
    // Validate and process
    return Response.json({ success: true, data });
  } catch (error) {
    return Response.json({ error: "Invalid request" }, { status: 400 });
  }
}
```

- Derive metadata from `appConfig` where possible to keep a single source of truth.
- Use `metadataBase: new URL(appConfig.app.baseUrl)` and `alternates.canonical` on top-level layout.
